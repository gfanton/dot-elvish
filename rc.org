#+property: header-args:elvish :tangle (concat (file-name-sans-extension (buffer-file-name)) ".elv")
#+property: header-args :mkdirp yes :comments no
#+startup: indent

#+title: My Elvish config file
#+author: Diego Zamboni
#+email: diego@zzamboni.org

#+begin_src elvish :exports none
  # DO NOT EDIT THIS FILE DIRECTLY
  # This is a file generated from a literate programing source file located at
  # https://github.com/zzamboni/dot-elvish/blob/master/rc.org.
  # You should make any changes there and regenerate it from Emacs org-mode using C-c C-v t
#+end_src

This is my main config file for [[http://elvish.io][Elvish]].

This file is written in [[http://www.howardism.org/Technical/Emacs/literate-programming-tutorial.html][literate programming style]], to make it easy
to explain. See [[file:rc.elv][rc.elv]] for the generated file.

* Table of Contents                                          :TOC_3:noexport:
- [[#paths][Paths]]
- [[#package-installation][Package installation]]
- [[#base-modules][Base modules]]
- [[#nix-package-manager][Nix package manager]]
- [[#completions][Completions]]
- [[#prompt-theme][Prompt theme]]
- [[#automatic-proxy-settings][Automatic proxy settings]]
- [[#long-running-command-notifications][Long-running-command notifications]]
- [[#directory-and-command-navigation-and-history][Directory and command navigation and history]]
- [[#aliases][Aliases]]
- [[#dynamic-terminal-title][Dynamic terminal title]]
- [[#loading-private-settings][Loading private settings]]
- [[#oreilly-atlas][O'Reilly Atlas]]
- [[#smart-matching-for-completion][Smart matching for completion]]
- [[#environment-variables][Environment variables]]
- [[#utility-functions][Utility functions]]

* Paths

First we set up the executable paths. We set the ~GOPATH~ environment
variable while we are at it, since we need to use it as part of the
path.

#+begin_src elvish
  E:GOPATH = ~/Personal/devel/go/
  paths = [
    ~/bin
    $E:GOPATH/bin
    ~/Dropbox/Personal/devel/hammerspoon/spoon/bin
    ~/.gem/ruby/2.4.0/bin
    /opt/X11/bin
    /Library/TeX/texbin
    /usr/local/bin
    /usr/local/sbin
    /usr/sbin
    /sbin
    /usr/bin
    /bin
  ]
#+end_src

* Package installation

The bundled [[https://elvish.io/ref/epm.html][epm]] module allows us to install and manage Elvish
packages.

#+begin_src elvish
  use epm
#+end_src

For now I use these packages:

- [[https://github.com/zzamboni/elvish-modules][github.com/zzamboni/elvish-modules]] contains all my modules except completions and
  themes. Maybe these should be separated eventually, but for now this
  works fine.
- [[https://github.com/zzamboni/elvish-themes][github.com/zzamboni/elvish-themes]] contains my prompt themes (only [[https://github.com/zzamboni/elvish-themes/blob/master/chain.org][chain]] for now).
- [[https://github.com/zzamboni/elvish-completions][github.com/zzamboni/elvish-completions]] contains my completer definitions.
- [[https://github.com/xiaq/edit.elv][github.com/xiaq/edit.elv]], which includes the =smart-matcher= module used below.

#+begin_src elvish
  epm:install &silent-if-installed=$true   \
    github.com/zzamboni/elvish-modules     \
    github.com/zzamboni/elvish-completions \
    github.com/zzamboni/elvish-themes      \
    github.com/xiaq/edit.elv
#+end_src

The modules within each package get loaded individually below.

* Base modules

Load the bundled [[https://elvish.io/ref/re.html][re]] module to have access to regular expression
functions.

#+begin_src elvish
  use re
#+end_src

The bundled [[https://elvish.io/ref/bundled.html][readline-binding]] module associates some Emacs-like
keybindings for manipulation of the command line.

#+begin_src elvish
  use readline-binding
#+end_src

I add a couple of keybindings which are missing from the default
=readline-binding= module:

- =Alt-backspace= to delete word

  #+begin_src elvish
    edit:insert:binding[Alt-Backspace] = $edit:kill-small-word-left~
  #+end_src

- =Alt-d= to delete the word under the cursor

  #+begin_src elvish
    edit:insert:binding[Alt-d] = { edit:move-dot-right-word; edit:kill-word-left }
  #+end_src

* Nix package manager

I use the [[https://nixos.org/nix/][Nix]] package manager on macOS, the [[https://github.com/zzamboni/modules.elv/blob/master/nix.org][nix]] module sets up the
necessary environment variables.

#+begin_src elvish
  use github.com/zzamboni/elvish-modules/nix
  nix:multi-user-setup
#+end_src

* Completions

From the  [[https://github.com/zzamboni/elvish-completions][elvish-completions]] package:

For =git=:

#+begin_src elvish
  use github.com/zzamboni/elvish-completions/git
#+end_src

For =vcsh= (uses the git completer):

#+begin_src elvish
  use github.com/zzamboni/elvish-completions/vcsh
#+end_src

For =cd=:

#+begin_src elvish
  use github.com/zzamboni/elvish-completions/cd
#+end_src

* Prompt theme

I use the [[https://github.com/zzamboni/theme.elv/blob/master/chain.org][chain]] prompt theme, ported from the fish theme at
https://github.com/oh-my-fish/theme-chain.

#+begin_src elvish
  use github.com/zzamboni/elvish-themes/chain
  chain:bold-prompt = $true
#+end_src

Since the git chain segments can slow things down a bit in large
repositories, I set the prompt caching timeout parameter.

#+begin_src elvish
  edit:-prompts-max-wait = 0.03
#+end_src

* Automatic proxy settings

When I am in the office, I need to use a proxy to access the
Internet. For macOS applications, the proxy is set automatically using
a company-provided PAC file. For the environment variables =http_proxy=
and =https_proxy=, commonly used by command-line programs, the [[https://github.com/zzamboni/modules.elv/blob/master/proxy.org][proxy]]
module allows me to define a test which determines when the proxy
should be used, so that the change is done automatically.

First, we load the module and set the proxy host.

#+begin_src elvish
  use github.com/zzamboni/elvish-modules/proxy
  proxy:host = "http://proxy.corproot.net:8079"
#+end_src

Next, we set the test function to enable proxy auto-setting. In my
case, the =/etc/resolv.conf= file contains the ~corproot.net~ domain (set
through DHCP) when I'm in the corporate network, so I can check for
that.

#+begin_src elvish
  proxy:test = {
    and ?(test -f /etc/resolv.conf) \
    ?(egrep -q '^(search|domain).*corproot.net' /etc/resolv.conf)
  }
#+end_src

* Long-running-command notifications

The [[https://github.com/zzamboni/modules.elv/blob/master/long-running-notifications.org][long-running-notifications]] module allows for producing a
notification when a command takes longer than a certain time to
finish (by default the period is 10 seconds). The module
automatically detects when [[https://github.com/julienXX/terminal-notifier][terminal-notifier]] is available on macOS
and uses it to produce Mac-style notifications, otherwise it prints
a notification on the terminal.

#+begin_src elvish
  use github.com/zzamboni/elvish-modules/long-running-notifications
#+end_src

* Directory and command navigation and history

Elvish comes with built-in location and command history modes. I use
the new (still experimental) =narrow= module, which allow for more
customization, including pre- and after- hooks for each of the
modes. I use the default binding for history mode (~C-r~), but change
the location mode binding to ~Alt-l~ to avoid conflicting with the binding of
~C-l~ to "clear screen" in =readline-binding=. I disable the
lastcmd binding because it is taken over by the =bang-bang= module
below.

#+begin_src elvish
  use narrow
  narrow:bind-trigger-keys &location=Alt-l &lastcmd=""
#+end_src

I have decades of muscle memory using ~!!~ and ~!$~ to insert the last
command and its last argument, respectively. The [[https://github.com/zzamboni/elvish-modules/blob/master/bang-bang.org][bang-bang]] module
allows me to keep using them.

#+begin_src elvish
  use github.com/zzamboni/elvish-modules/bang-bang
#+end_src

The [[https://github.com/zzamboni/modules.elv/blob/master/dir.org][dir]] module implements a directory history and some related
functions. I override the built-in ~cd~ command with a function that
calls =dir:cd= so that any directory changes are kept in the history. I
also create a top-level wrapper for the =dir:cdb= function, which allows
changing to the base directory of the argument. The module also
implements a narrow-based directory history chooser, which I bind to
~Alt-i~. I have Terminal.app configured to produce =Alt-b= when =Alt-left=
is pressed, and =Alt-f= when =Alt-right= is pressed, so I bind those keys
to the =dir:left-word-or-prev-dir= and =dir:right-word-or-next-dir=
functions, which do the right thing depending on the current content
of the command prompt (i.e. if it's empty, they move back/forward in
the directory history, otherwise they move through the words of the
current command).

#+begin_src elvish
  use github.com/zzamboni/elvish-modules/dir
  edit:insert:binding[Alt-b] = $dir:left-word-or-prev-dir~
  edit:insert:binding[Alt-f] = $dir:right-word-or-next-dir~
  edit:insert:binding[Alt-i] = $dir:history-chooser~
  fn cd [@dir]{ dir:cd $@dir }
  fn cdb [@dir]{ dir:cdb $@dir }
#+end_src

* Aliases

Elvish does not have built-in alias functionality, but this is
implemented easily using the [[https://github.com/zzamboni/modules.elv/blob/master/alias.org][alias]] module, which stores the alias
definitions as functions under [[https://github.com/zzamboni/dot-elvish/tree/master/aliases][~/.elvish/aliases/]] and loads them
automatically.

#+begin_src elvish
  use github.com/zzamboni/elvish-modules/alias
#+end_src

* Dynamic terminal title

The [[https://github.com/zzamboni/elvish-modules/blob/master/terminal-title.org][terminal-title]] module handles setting the terminal title
dynamically according to the current directory or the current command
being executed.

#+begin_src elvish
  use github.com/zzamboni/elvish-modules/terminal-title
#+end_src

* Loading private settings

The =private= module sets up some private settings such as
authentication tokens. This is not on github :) The =$private-loaded=
variable gets set to =$ok= if the module was loaded correctly.

#+begin_src elvish
  private-loaded = ?(use private)
#+end_src

* O'Reilly Atlas

I sometimes use the [[https://atlas.oreilly.com/][O'Reilly Atlas]] publishing platform. The [[https://github.com/zzamboni/modules.elv/blob/master/atlas.org][atlas]]
module contains some useful functions for triggering and accessing
document builds.

#+begin_src elvish
  use github.com/zzamboni/elvish-modules/atlas
#+end_src

* Smart matching for completion

The [[https://github.com/xiaq/edit.elv/blob/master/smart-matcher.elv][smart-matcher]] module tries prefix match, smart-case prefix match,
substring match, smart-case substring match, subsequence match and
smart-case subsequence match automatically.

#+begin_src elvish
  use github.com/xiaq/edit.elv/smart-matcher
  edit:-matcher[''] = $smart-matcher:match~
#+end_src

Other possible values for =edit:-matcher= are =[p]{ edit:match-prefix
&smart-case $p }= for smart-case completion (if your pattern is
entirely lower case it ignores case, otherwise it's case sensitive).
=&smart-case= can be replaced with =&ignore-case= to make it always
case-insensitive.

* Environment variables

Default options to =less=.

#+begin_src elvish
  E:LESS = "-i -R"
#+end_src

Use vim as the editor from the command line (although I am an Emacs
fan, I still prefer vim for quick editing).

#+begin_src elvish
  E:EDITOR = "vim"
#+end_src

Locale setting.

#+begin_src elvish
  E:LC_ALL = "en_US.UTF-8"
#+end_src

* Utility functions

The [[https://github.com/zzamboni/elvish-modules/blob/master/util.org][util]] module includes various utility functions.

#+begin_src elvish
  use github.com/zzamboni/elvish-modules/util
#+end_src
